/* soapC_nnn.cpp
   Generated by gSOAP 2.8.91 for gen/onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.91 2024-07-01 07:07:52 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, std::vector<_wstop__TopicNamespaceType_Topic> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const std::vector<_wstop__TopicNamespaceType_Topic> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wstop__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_wstop__TopicNamespaceType_Topic n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wstop__TopicNamespaceType_Topic));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_wstop__TopicNamespaceType_Topic));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wstop__TopicNamespaceType_Topic));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wstop__TopicNamespaceType_Topic> *p;
	size_t k = sizeof(std::vector<_wstop__TopicNamespaceType_Topic> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wstop__TopicNamespaceType_Topic> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wstop__TopicNamespaceType_Topic> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wstop__TopicNamespaceType_Topic>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const std::vector<wstop__TopicType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowstop__TopicType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, const std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowstop__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wstop__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wstop__TopicType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wstop__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, sizeof(wstop__TopicType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowstop__TopicType(soap, tag, &n, "wstop:TopicType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wstop__TopicType *> *p;
	size_t k = sizeof(std::vector<wstop__TopicType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wstop__TopicType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wstop__TopicType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wstop__TopicType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__QName(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const std::vector<_wsrfbf__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_wsrfbf__BaseFaultType_Description n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__wsrfbf__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wsrfbf__BaseFaultType_Description));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_wsrfbf__BaseFaultType_Description));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_wsrfbf__BaseFaultType_Description));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wsrfbf__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_wsrfbf__BaseFaultType_Description> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wsrfbf__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wsrfbf__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wsrfbf__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, std::vector<timg__ImagingPreset *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const std::vector<timg__ImagingPreset *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotimg__ImagingPreset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, const std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotimg__ImagingPreset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<timg__ImagingPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		timg__ImagingPreset *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, sizeof(timg__ImagingPreset), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, NULL, "timg:ImagingPreset"))
				break;
		}
		else
		{	if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, &n, "timg:ImagingPreset"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<timg__ImagingPreset *> *p;
	size_t k = sizeof(std::vector<timg__ImagingPreset *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<timg__ImagingPreset *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<timg__ImagingPreset *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<timg__ImagingPreset *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__MediaAttributes(struct soap *soap, std::vector<tt__MediaAttributes *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__MediaAttributes(struct soap *soap, const std::vector<tt__MediaAttributes *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__MediaAttributes *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__MediaAttributes(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__MediaAttributes(struct soap *soap, const char *tag, int id, const std::vector<tt__MediaAttributes *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__MediaAttributes *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__MediaAttributes(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__MediaAttributes *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__MediaAttributes(struct soap *soap, const char *tag, std::vector<tt__MediaAttributes *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__MediaAttributes(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__MediaAttributes *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__MediaAttributes, SOAP_TYPE_std__vectorTemplateOfPointerTott__MediaAttributes, sizeof(tt__MediaAttributes), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__MediaAttributes(soap, tag, NULL, "tt:MediaAttributes"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__MediaAttributes(soap, tag, &n, "tt:MediaAttributes"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__MediaAttributes *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__MediaAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__MediaAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__MediaAttributes *> *p;
	size_t k = sizeof(std::vector<tt__MediaAttributes *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__MediaAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__MediaAttributes *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__MediaAttributes *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__MediaAttributes *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, std::vector<tt__OSDConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, const std::vector<tt__OSDConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__OSDConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OSDConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__OSDConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OSDConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OSDConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OSDConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, const char *tag, std::vector<tt__OSDConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OSDConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__OSDConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__OSDConfiguration, sizeof(tt__OSDConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__OSDConfiguration(soap, tag, NULL, "tt:OSDConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__OSDConfiguration(soap, tag, &n, "tt:OSDConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OSDConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OSDConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OSDConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__OSDConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__OSDConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OSDConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OSDConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OSDConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, std::vector<trt__VideoSourceMode *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, const std::vector<trt__VideoSourceMode *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<trt__VideoSourceMode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotrt__VideoSourceMode(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, int id, const std::vector<trt__VideoSourceMode *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<trt__VideoSourceMode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotrt__VideoSourceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<trt__VideoSourceMode *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, std::vector<trt__VideoSourceMode *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotrt__VideoSourceMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		trt__VideoSourceMode *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_trt__VideoSourceMode, SOAP_TYPE_std__vectorTemplateOfPointerTotrt__VideoSourceMode, sizeof(trt__VideoSourceMode), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotrt__VideoSourceMode(soap, tag, NULL, "trt:VideoSourceMode"))
				break;
		}
		else
		{	if (!soap_in_PointerTotrt__VideoSourceMode(soap, tag, &n, "trt:VideoSourceMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<trt__VideoSourceMode *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotrt__VideoSourceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<trt__VideoSourceMode *> *p;
	size_t k = sizeof(std::vector<trt__VideoSourceMode *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotrt__VideoSourceMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<trt__VideoSourceMode *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<trt__VideoSourceMode *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<trt__VideoSourceMode *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, std::vector<tt__AudioDecoderConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, const std::vector<tt__AudioDecoderConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioDecoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioDecoderConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioDecoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioDecoderConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioDecoderConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioDecoderConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, NULL, "tt:AudioDecoderConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, &n, "tt:AudioDecoderConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioDecoderConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioDecoderConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioDecoderConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioDecoderConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioDecoderConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioDecoderConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, std::vector<tt__AudioOutputConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, const std::vector<tt__AudioOutputConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioOutputConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioOutputConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioOutputConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioOutputConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioOutputConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioOutputConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioOutputConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioOutputConfiguration(soap, tag, NULL, "tt:AudioOutputConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioOutputConfiguration(soap, tag, &n, "tt:AudioOutputConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioOutputConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioOutputConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioOutputConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioOutputConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioOutputConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioOutputConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, std::vector<tt__MetadataConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, const std::vector<tt__MetadataConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__MetadataConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__MetadataConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__MetadataConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__MetadataConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__MetadataConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__MetadataConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, const char *tag, std::vector<tt__MetadataConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__MetadataConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__MetadataConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__MetadataConfiguration(soap, tag, NULL, "tt:MetadataConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__MetadataConfiguration(soap, tag, &n, "tt:MetadataConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__MetadataConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__MetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__MetadataConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__MetadataConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__MetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__MetadataConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__MetadataConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__MetadataConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, std::vector<tt__VideoAnalyticsConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const std::vector<tt__VideoAnalyticsConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoAnalyticsConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoAnalyticsConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoAnalyticsConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoAnalyticsConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, std::vector<tt__VideoAnalyticsConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoAnalyticsConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, NULL, "tt:VideoAnalyticsConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, &n, "tt:VideoAnalyticsConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoAnalyticsConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoAnalyticsConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__VideoAnalyticsConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoAnalyticsConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoAnalyticsConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoAnalyticsConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, std::vector<tt__AudioSourceConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, const std::vector<tt__AudioSourceConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioSourceConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioSourceConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioSourceConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioSourceConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioSourceConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioSourceConfiguration(soap, tag, NULL, "tt:AudioSourceConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioSourceConfiguration(soap, tag, &n, "tt:AudioSourceConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioSourceConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioSourceConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioSourceConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioSourceConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioSourceConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioSourceConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, std::vector<tt__AudioEncoderConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, const std::vector<tt__AudioEncoderConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioEncoderConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioEncoderConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioEncoderConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioEncoderConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, NULL, "tt:AudioEncoderConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, &n, "tt:AudioEncoderConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioEncoderConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioEncoderConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioEncoderConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioEncoderConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioEncoderConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, std::vector<tt__VideoSourceConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, const std::vector<tt__VideoSourceConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoSourceConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoSourceConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoSourceConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, std::vector<tt__VideoSourceConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoSourceConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoSourceConfiguration(soap, tag, NULL, "tt:VideoSourceConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoSourceConfiguration(soap, tag, &n, "tt:VideoSourceConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoSourceConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoSourceConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__VideoSourceConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoSourceConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoSourceConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoSourceConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, std::vector<tt__VideoEncoderConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, const std::vector<tt__VideoEncoderConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoEncoderConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoEncoderConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, std::vector<tt__VideoEncoderConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoEncoderConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, NULL, "tt:VideoEncoderConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, &n, "tt:VideoEncoderConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoEncoderConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoEncoderConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__VideoEncoderConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoEncoderConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoEncoderConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoEncoderConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, std::vector<tt__Profile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const std::vector<tt__Profile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Profile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__Profile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Profile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const char *tag, std::vector<tt__Profile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Profile(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Profile *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Profile, SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile, sizeof(tt__Profile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Profile(soap, tag, NULL, "tt:Profile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Profile(soap, tag, &n, "tt:Profile"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Profile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Profile *> *p;
	size_t k = sizeof(std::vector<tt__Profile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Profile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Profile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Profile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, std::vector<tt__AudioOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const std::vector<tt__AudioOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const char *tag, std::vector<tt__AudioOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioOutput(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioOutput *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput, sizeof(tt__AudioOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioOutput(soap, tag, NULL, "tt:AudioOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioOutput(soap, tag, &n, "tt:AudioOutput"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioOutput *> *p;
	size_t k = sizeof(std::vector<tt__AudioOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, std::vector<tt__AudioSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const std::vector<tt__AudioSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const char *tag, std::vector<tt__AudioSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioSource(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioSource *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource, sizeof(tt__AudioSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioSource(soap, tag, NULL, "tt:AudioSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioSource(soap, tag, &n, "tt:AudioSource"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioSource *> *p;
	size_t k = sizeof(std::vector<tt__AudioSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, std::vector<tt__VideoSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, const std::vector<tt__VideoSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, const char *tag, std::vector<tt__VideoSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoSource(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoSource *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSource, sizeof(tt__VideoSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoSource(soap, tag, NULL, "tt:VideoSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoSource(soap, tag, &n, "tt:VideoSource"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoSource *> *p;
	size_t k = sizeof(std::vector<tt__VideoSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, std::vector<tt__FileProgress *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, const std::vector<tt__FileProgress *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FileProgress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FileProgress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, const char *tag, int id, const std::vector<tt__FileProgress *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FileProgress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FileProgress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FileProgress *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, const char *tag, std::vector<tt__FileProgress *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FileProgress(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__FileProgress *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__FileProgress, SOAP_TYPE_std__vectorTemplateOfPointerTott__FileProgress, sizeof(tt__FileProgress), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FileProgress(soap, tag, NULL, "tt:FileProgress"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FileProgress(soap, tag, &n, "tt:FileProgress"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FileProgress *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FileProgress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FileProgress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FileProgress *> *p;
	size_t k = sizeof(std::vector<tt__FileProgress *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FileProgress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FileProgress *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FileProgress *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FileProgress *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__OSDType(struct soap *soap, std::vector<enum tt__OSDType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__OSDType(struct soap *soap, const std::vector<enum tt__OSDType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__OSDType(struct soap *soap, const char *tag, int id, const std::vector<enum tt__OSDType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__OSDType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__OSDType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__OSDType> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__OSDType(struct soap *soap, const char *tag, std::vector<enum tt__OSDType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__OSDType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__OSDType n;
		soap_default_tt__OSDType(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__OSDType, SOAP_TYPE_std__vectorTemplateOftt__OSDType, sizeof(enum tt__OSDType), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__OSDType(soap, tag, NULL, "tt:OSDType"))
				break;
		}
		else
		{	if (!soap_in_tt__OSDType(soap, tag, &n, "tt:OSDType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__OSDType>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__OSDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__OSDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__OSDType> *p;
	size_t k = sizeof(std::vector<enum tt__OSDType> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__OSDType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__OSDType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__OSDType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__OSDType>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const std::vector<tt__ColorspaceRange *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ColorspaceRange(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, const std::vector<tt__ColorspaceRange *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ColorspaceRange(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, std::vector<tt__ColorspaceRange *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ColorspaceRange(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__ColorspaceRange *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange, sizeof(tt__ColorspaceRange), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ColorspaceRange(soap, tag, NULL, "tt:ColorspaceRange"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ColorspaceRange(soap, tag, &n, "tt:ColorspaceRange"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ColorspaceRange *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ColorspaceRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ColorspaceRange *> *p;
	size_t k = sizeof(std::vector<tt__ColorspaceRange *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ColorspaceRange *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ColorspaceRange *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ColorspaceRange *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const std::vector<tt__Color *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Color(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, int id, const std::vector<tt__Color *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Color(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Color *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, std::vector<tt__Color *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Color(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Color *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Color, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color, sizeof(tt__Color), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Color(soap, tag, NULL, "tt:Color"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Color(soap, tag, &n, "tt:Color"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Color *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Color(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Color(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Color *> *p;
	size_t k = sizeof(std::vector<tt__Color *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Color *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Color *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Color *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, std::vector<tt__ActiveConnection *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, const std::vector<tt__ActiveConnection *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ActiveConnection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ActiveConnection(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, const char *tag, int id, const std::vector<tt__ActiveConnection *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ActiveConnection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ActiveConnection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ActiveConnection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, const char *tag, std::vector<tt__ActiveConnection *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ActiveConnection(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__ActiveConnection *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ActiveConnection, SOAP_TYPE_std__vectorTemplateOfPointerTott__ActiveConnection, sizeof(tt__ActiveConnection), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ActiveConnection(soap, tag, NULL, "tt:ActiveConnection"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ActiveConnection(soap, tag, &n, "tt:ActiveConnection"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ActiveConnection *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ActiveConnection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ActiveConnection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ActiveConnection *> *p;
	size_t k = sizeof(std::vector<tt__ActiveConnection *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ActiveConnection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ActiveConnection *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ActiveConnection *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ActiveConnection *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, std::vector<tt__AudioClassCandidate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, const std::vector<tt__AudioClassCandidate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioClassCandidate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioClassCandidate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioClassCandidate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioClassCandidate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioClassCandidate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioClassCandidate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, const char *tag, std::vector<tt__AudioClassCandidate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioClassCandidate(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioClassCandidate *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioClassCandidate, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioClassCandidate, sizeof(tt__AudioClassCandidate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioClassCandidate(soap, tag, NULL, "tt:AudioClassCandidate"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioClassCandidate(soap, tag, &n, "tt:AudioClassCandidate"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioClassCandidate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioClassCandidate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioClassCandidate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioClassCandidate *> *p;
	size_t k = sizeof(std::vector<tt__AudioClassCandidate *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioClassCandidate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioClassCandidate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioClassCandidate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioClassCandidate *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, std::vector<tt__EngineConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, const std::vector<tt__EngineConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__EngineConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__EngineConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__EngineConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__EngineConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__EngineConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__EngineConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, const char *tag, std::vector<tt__EngineConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__EngineConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__EngineConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__EngineConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__EngineConfiguration, sizeof(tt__EngineConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__EngineConfiguration(soap, tag, NULL, "tt:EngineConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__EngineConfiguration(soap, tag, &n, "tt:EngineConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__EngineConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__EngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__EngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__EngineConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__EngineConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__EngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__EngineConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__EngineConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__EngineConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, std::vector<tt__RecordingJobStateTrack *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, const std::vector<tt__RecordingJobStateTrack *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobStateTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobStateTrack(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobStateTrack *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobStateTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobStateTrack *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, std::vector<tt__RecordingJobStateTrack *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RecordingJobStateTrack *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RecordingJobStateTrack, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobStateTrack(soap, tag, NULL, "tt:RecordingJobStateTrack"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobStateTrack(soap, tag, &n, "tt:RecordingJobStateTrack"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobStateTrack *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateTrack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobStateTrack *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobStateTrack *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateTrack, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobStateTrack *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobStateTrack *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobStateTrack *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, std::vector<tt__RecordingJobStateSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, const std::vector<tt__RecordingJobStateSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobStateSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobStateSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobStateSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobStateSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobStateSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobStateSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, std::vector<tt__RecordingJobStateSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobStateSource(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RecordingJobStateSource *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RecordingJobStateSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobStateSource(soap, tag, NULL, "tt:RecordingJobStateSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobStateSource(soap, tag, &n, "tt:RecordingJobStateSource"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobStateSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobStateSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobStateSource *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobStateSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobStateSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobStateSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobStateSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, std::vector<tt__RecordingJobTrack *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, const std::vector<tt__RecordingJobTrack *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobTrack(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobTrack *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobTrack *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobTrack(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobTrack *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, const char *tag, std::vector<tt__RecordingJobTrack *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobTrack(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RecordingJobTrack *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RecordingJobTrack, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobTrack, sizeof(tt__RecordingJobTrack), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobTrack(soap, tag, NULL, "tt:RecordingJobTrack"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobTrack(soap, tag, &n, "tt:RecordingJobTrack"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobTrack *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobTrack(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobTrack(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobTrack *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobTrack *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobTrack, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobTrack *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobTrack *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobTrack *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, std::vector<tt__RecordingJobSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, const std::vector<tt__RecordingJobSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingJobSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingJobSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingJobSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingJobSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingJobSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingJobSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, const char *tag, std::vector<tt__RecordingJobSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingJobSource(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RecordingJobSource *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RecordingJobSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobSource, sizeof(tt__RecordingJobSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingJobSource(soap, tag, NULL, "tt:RecordingJobSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingJobSource(soap, tag, &n, "tt:RecordingJobSource"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingJobSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingJobSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingJobSource *> *p;
	size_t k = sizeof(std::vector<tt__RecordingJobSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingJobSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingJobSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingJobSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, std::vector<tt__GetTracksResponseItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, const std::vector<tt__GetTracksResponseItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__GetTracksResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__GetTracksResponseItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, const std::vector<tt__GetTracksResponseItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__GetTracksResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__GetTracksResponseItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__GetTracksResponseItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, std::vector<tt__GetTracksResponseItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__GetTracksResponseItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__GetTracksResponseItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__GetTracksResponseItem, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__GetTracksResponseItem(soap, tag, NULL, "tt:GetTracksResponseItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__GetTracksResponseItem(soap, tag, &n, "tt:GetTracksResponseItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__GetTracksResponseItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__GetTracksResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__GetTracksResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__GetTracksResponseItem *> *p;
	size_t k = sizeof(std::vector<tt__GetTracksResponseItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetTracksResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__GetTracksResponseItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__GetTracksResponseItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__GetTracksResponseItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, std::vector<tt__TrackAttributes *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, const std::vector<tt__TrackAttributes *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__TrackAttributes *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__TrackAttributes(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, const std::vector<tt__TrackAttributes *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__TrackAttributes *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__TrackAttributes(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__TrackAttributes *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, const char *tag, std::vector<tt__TrackAttributes *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__TrackAttributes(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__TrackAttributes *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__TrackAttributes, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackAttributes, sizeof(tt__TrackAttributes), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__TrackAttributes(soap, tag, NULL, "tt:TrackAttributes"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__TrackAttributes(soap, tag, &n, "tt:TrackAttributes"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__TrackAttributes *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__TrackAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__TrackAttributes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__TrackAttributes *> *p;
	size_t k = sizeof(std::vector<tt__TrackAttributes *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackAttributes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__TrackAttributes *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__TrackAttributes *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__TrackAttributes *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, std::vector<tt__TrackInformation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, const std::vector<tt__TrackInformation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__TrackInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__TrackInformation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, const char *tag, int id, const std::vector<tt__TrackInformation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__TrackInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__TrackInformation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__TrackInformation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, const char *tag, std::vector<tt__TrackInformation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__TrackInformation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__TrackInformation *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__TrackInformation, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackInformation, sizeof(tt__TrackInformation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__TrackInformation(soap, tag, NULL, "tt:TrackInformation"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__TrackInformation(soap, tag, &n, "tt:TrackInformation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__TrackInformation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__TrackInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__TrackInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__TrackInformation *> *p;
	size_t k = sizeof(std::vector<tt__TrackInformation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__TrackInformation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__TrackInformation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__TrackInformation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, std::vector<tt__FindMetadataResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, const std::vector<tt__FindMetadataResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FindMetadataResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FindMetadataResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, const std::vector<tt__FindMetadataResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FindMetadataResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FindMetadataResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FindMetadataResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, const char *tag, std::vector<tt__FindMetadataResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FindMetadataResult(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__FindMetadataResult *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__FindMetadataResult, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindMetadataResult, sizeof(tt__FindMetadataResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FindMetadataResult(soap, tag, NULL, "tt:FindMetadataResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FindMetadataResult(soap, tag, &n, "tt:FindMetadataResult"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FindMetadataResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FindMetadataResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FindMetadataResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FindMetadataResult *> *p;
	size_t k = sizeof(std::vector<tt__FindMetadataResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindMetadataResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FindMetadataResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FindMetadataResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FindMetadataResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, std::vector<tt__FindPTZPositionResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, const std::vector<tt__FindPTZPositionResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FindPTZPositionResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FindPTZPositionResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, const std::vector<tt__FindPTZPositionResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FindPTZPositionResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FindPTZPositionResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FindPTZPositionResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, std::vector<tt__FindPTZPositionResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FindPTZPositionResult(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__FindPTZPositionResult *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__FindPTZPositionResult, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FindPTZPositionResult(soap, tag, NULL, "tt:FindPTZPositionResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FindPTZPositionResult(soap, tag, &n, "tt:FindPTZPositionResult"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FindPTZPositionResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FindPTZPositionResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FindPTZPositionResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FindPTZPositionResult *> *p;
	size_t k = sizeof(std::vector<tt__FindPTZPositionResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindPTZPositionResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FindPTZPositionResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FindPTZPositionResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FindPTZPositionResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, std::vector<tt__FindEventResult *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, const std::vector<tt__FindEventResult *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__FindEventResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__FindEventResult(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, const char *tag, int id, const std::vector<tt__FindEventResult *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__FindEventResult *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__FindEventResult(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__FindEventResult *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, const char *tag, std::vector<tt__FindEventResult *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__FindEventResult(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__FindEventResult *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__FindEventResult, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindEventResult, sizeof(tt__FindEventResult), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__FindEventResult(soap, tag, NULL, "tt:FindEventResult"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__FindEventResult(soap, tag, &n, "tt:FindEventResult"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__FindEventResult *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__FindEventResult(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__FindEventResult(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__FindEventResult *> *p;
	size_t k = sizeof(std::vector<tt__FindEventResult *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__FindEventResult, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__FindEventResult *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__FindEventResult *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__FindEventResult *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, std::vector<tt__RecordingInformation *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, const std::vector<tt__RecordingInformation *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RecordingInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RecordingInformation(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, const std::vector<tt__RecordingInformation *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RecordingInformation *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RecordingInformation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RecordingInformation *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, const char *tag, std::vector<tt__RecordingInformation *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RecordingInformation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RecordingInformation *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RecordingInformation, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingInformation, sizeof(tt__RecordingInformation), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RecordingInformation(soap, tag, NULL, "tt:RecordingInformation"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RecordingInformation(soap, tag, &n, "tt:RecordingInformation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RecordingInformation *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RecordingInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RecordingInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RecordingInformation *> *p;
	size_t k = sizeof(std::vector<tt__RecordingInformation *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RecordingInformation *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RecordingInformation *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RecordingInformation *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__RecordingReference(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__RecordingReference(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__RecordingReference(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__RecordingReference(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__RecordingReference(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__RecordingReference(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__RecordingReference(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__RecordingReference(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RecordingReference, SOAP_TYPE_std__vectorTemplateOftt__RecordingReference, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__RecordingReference(soap, tag, NULL, "tt:RecordingReference"))
				break;
		}
		else
		{	if (!soap_in_tt__RecordingReference(soap, tag, &n, "tt:RecordingReference"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__RecordingReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__RecordingReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__RecordingReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, std::vector<tt__SourceReference *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, const std::vector<tt__SourceReference *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__SourceReference *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__SourceReference(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, const char *tag, int id, const std::vector<tt__SourceReference *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SourceReference *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__SourceReference(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SourceReference *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, const char *tag, std::vector<tt__SourceReference *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__SourceReference(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__SourceReference *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__SourceReference, SOAP_TYPE_std__vectorTemplateOfPointerTott__SourceReference, sizeof(tt__SourceReference), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__SourceReference(soap, tag, NULL, "tt:SourceReference"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__SourceReference(soap, tag, &n, "tt:SourceReference"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SourceReference *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__SourceReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__SourceReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SourceReference *> *p;
	size_t k = sizeof(std::vector<tt__SourceReference *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__SourceReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SourceReference *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SourceReference *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SourceReference *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, std::vector<tt__Rectangle *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, const std::vector<tt__Rectangle *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Rectangle *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Rectangle(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, const char *tag, int id, const std::vector<tt__Rectangle *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Rectangle *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Rectangle(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Rectangle *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, const char *tag, std::vector<tt__Rectangle *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Rectangle(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Rectangle *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Rectangle, SOAP_TYPE_std__vectorTemplateOfPointerTott__Rectangle, sizeof(tt__Rectangle), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Rectangle(soap, tag, NULL, "tt:Rectangle"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Rectangle(soap, tag, &n, "tt:Rectangle"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Rectangle *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Rectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Rectangle *> *p;
	size_t k = sizeof(std::vector<tt__Rectangle *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Rectangle, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Rectangle *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Rectangle *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Rectangle *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, std::vector<tt__PaneLayoutOptions *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, const std::vector<tt__PaneLayoutOptions *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PaneLayoutOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PaneLayoutOptions(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, int id, const std::vector<tt__PaneLayoutOptions *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PaneLayoutOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PaneLayoutOptions(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PaneLayoutOptions *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, std::vector<tt__PaneLayoutOptions *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PaneLayoutOptions(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PaneLayoutOptions *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PaneLayoutOptions, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayoutOptions, sizeof(tt__PaneLayoutOptions), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PaneLayoutOptions(soap, tag, NULL, "tt:PaneLayoutOptions"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PaneLayoutOptions(soap, tag, &n, "tt:PaneLayoutOptions"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PaneLayoutOptions *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayoutOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayoutOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PaneLayoutOptions *> *p;
	size_t k = sizeof(std::vector<tt__PaneLayoutOptions *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayoutOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PaneLayoutOptions *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PaneLayoutOptions *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PaneLayoutOptions *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, std::vector<tt__PaneLayout *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, const std::vector<tt__PaneLayout *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PaneLayout *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PaneLayout(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, const char *tag, int id, const std::vector<tt__PaneLayout *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PaneLayout *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PaneLayout(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PaneLayout *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, const char *tag, std::vector<tt__PaneLayout *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PaneLayout(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PaneLayout *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PaneLayout, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout, sizeof(tt__PaneLayout), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PaneLayout(soap, tag, NULL, "tt:PaneLayout"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PaneLayout(soap, tag, &n, "tt:PaneLayout"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PaneLayout *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PaneLayout(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PaneLayout *> *p;
	size_t k = sizeof(std::vector<tt__PaneLayout *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PaneLayout *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PaneLayout *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PaneLayout *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, std::vector<tt__Polyline *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, const std::vector<tt__Polyline *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Polyline *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Polyline(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, const char *tag, int id, const std::vector<tt__Polyline *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Polyline *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Polyline(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Polyline *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, const char *tag, std::vector<tt__Polyline *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Polyline(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Polyline *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Polyline, SOAP_TYPE_std__vectorTemplateOfPointerTott__Polyline, sizeof(tt__Polyline), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Polyline(soap, tag, NULL, "tt:Polyline"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Polyline(soap, tag, &n, "tt:Polyline"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Polyline *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Polyline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Polyline(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Polyline *> *p;
	size_t k = sizeof(std::vector<tt__Polyline *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Polyline, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Polyline *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Polyline *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Polyline *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, std::vector<tt__ConfigDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const std::vector<tt__ConfigDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ConfigDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ConfigDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__ConfigDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ConfigDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ConfigDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ConfigDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, const char *tag, std::vector<tt__ConfigDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ConfigDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__ConfigDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription, sizeof(tt__ConfigDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ConfigDescription(soap, tag, NULL, "tt:ConfigDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ConfigDescription(soap, tag, &n, "tt:ConfigDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ConfigDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ConfigDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ConfigDescription *> *p;
	size_t k = sizeof(std::vector<tt__ConfigDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ConfigDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ConfigDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ConfigDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, std::vector<_tt__ConfigDescription_Messages> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, const std::vector<_tt__ConfigDescription_Messages> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ConfigDescription_Messages> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const std::vector<_tt__ConfigDescription_Messages> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ConfigDescription_Messages> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ConfigDescription_Messages> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, std::vector<_tt__ConfigDescription_Messages> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ConfigDescription_Messages(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ConfigDescription_Messages n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ConfigDescription_Messages, SOAP_TYPE_std__vectorTemplateOf_tt__ConfigDescription_Messages, sizeof(_tt__ConfigDescription_Messages), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ConfigDescription_Messages(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ConfigDescription_Messages(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ConfigDescription_Messages));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ConfigDescription_Messages));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ConfigDescription_Messages));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ConfigDescription_Messages>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ConfigDescription_Messages(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ConfigDescription_Messages(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ConfigDescription_Messages> *p;
	size_t k = sizeof(std::vector<_tt__ConfigDescription_Messages> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ConfigDescription_Messages, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ConfigDescription_Messages> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ConfigDescription_Messages> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ConfigDescription_Messages>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Config(struct soap *soap, std::vector<tt__Config *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const std::vector<tt__Config *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Config(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, int id, const std::vector<tt__Config *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Config(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Config *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, std::vector<tt__Config *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Config(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Config *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Config, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, sizeof(tt__Config), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Config(soap, tag, NULL, "tt:Config"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Config(soap, tag, &n, "tt:Config"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Config *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Config *> *p;
	size_t k = sizeof(std::vector<tt__Config *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Config *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Config *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Config *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, std::vector<_tt__ItemListDescription_ElementItemDescription> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const std::vector<_tt__ItemListDescription_ElementItemDescription> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemListDescription_ElementItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemListDescription_ElementItemDescription> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemListDescription_ElementItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemListDescription_ElementItemDescription> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, std::vector<_tt__ItemListDescription_ElementItemDescription> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ItemListDescription_ElementItemDescription n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription, sizeof(_tt__ItemListDescription_ElementItemDescription), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemListDescription_ElementItemDescription));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemListDescription_ElementItemDescription));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemListDescription_ElementItemDescription));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemListDescription_ElementItemDescription>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemListDescription_ElementItemDescription> *p;
	size_t k = sizeof(std::vector<_tt__ItemListDescription_ElementItemDescription> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemListDescription_ElementItemDescription> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemListDescription_ElementItemDescription> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemListDescription_ElementItemDescription>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, std::vector<_tt__ItemListDescription_SimpleItemDescription> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const std::vector<_tt__ItemListDescription_SimpleItemDescription> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemListDescription_SimpleItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemListDescription_SimpleItemDescription> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemListDescription_SimpleItemDescription> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemListDescription_SimpleItemDescription> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, std::vector<_tt__ItemListDescription_SimpleItemDescription> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ItemListDescription_SimpleItemDescription n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription, sizeof(_tt__ItemListDescription_SimpleItemDescription), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemListDescription_SimpleItemDescription));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemListDescription_SimpleItemDescription));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemListDescription_SimpleItemDescription));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemListDescription_SimpleItemDescription>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemListDescription_SimpleItemDescription> *p;
	size_t k = sizeof(std::vector<_tt__ItemListDescription_SimpleItemDescription> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemListDescription_SimpleItemDescription> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemListDescription_SimpleItemDescription> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemListDescription_SimpleItemDescription>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, std::vector<_tt__ItemList_ElementItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const std::vector<_tt__ItemList_ElementItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_ElementItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_ElementItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ItemList_ElementItem n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemList_ElementItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_ElementItem(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_ElementItem));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_ElementItem));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_ElementItem));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_ElementItem>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_ElementItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_ElementItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_ElementItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_ElementItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_ElementItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, std::vector<_tt__ItemList_SimpleItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const std::vector<_tt__ItemList_SimpleItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_SimpleItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ItemList_SimpleItem n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemList_SimpleItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_SimpleItem(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_SimpleItem));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_SimpleItem));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ItemList_SimpleItem));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_SimpleItem>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_SimpleItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_SimpleItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_SimpleItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_SimpleItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_SimpleItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, std::vector<enum tt__BacklightCompensationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const std::vector<enum tt__BacklightCompensationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__BacklightCompensationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__BacklightCompensationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__BacklightCompensationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__BacklightCompensationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, std::vector<enum tt__BacklightCompensationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__BacklightCompensationMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__BacklightCompensationMode n;
		soap_default_tt__BacklightCompensationMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__BacklightCompensationMode(soap, tag, NULL, "tt:BacklightCompensationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__BacklightCompensationMode(soap, tag, &n, "tt:BacklightCompensationMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__BacklightCompensationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__BacklightCompensationMode> *p;
	size_t k = sizeof(std::vector<enum tt__BacklightCompensationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__BacklightCompensationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__BacklightCompensationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__BacklightCompensationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, std::vector<enum tt__ImageStabilizationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const std::vector<enum tt__ImageStabilizationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ImageStabilizationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ImageStabilizationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ImageStabilizationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ImageStabilizationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, std::vector<enum tt__ImageStabilizationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ImageStabilizationMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ImageStabilizationMode n;
		soap_default_tt__ImageStabilizationMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ImageStabilizationMode(soap, tag, NULL, "tt:ImageStabilizationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ImageStabilizationMode(soap, tag, &n, "tt:ImageStabilizationMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ImageStabilizationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ImageStabilizationMode> *p;
	size_t k = sizeof(std::vector<enum tt__ImageStabilizationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ImageStabilizationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ImageStabilizationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ImageStabilizationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, std::vector<tt__IrCutFilterAutoAdjustment *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const std::vector<tt__IrCutFilterAutoAdjustment *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IrCutFilterAutoAdjustment(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IrCutFilterAutoAdjustment *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__IrCutFilterAutoAdjustment *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, NULL, "tt:IrCutFilterAutoAdjustment"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, &n, "tt:IrCutFilterAutoAdjustment"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterAutoAdjustment *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IrCutFilterAutoAdjustment *> *p;
	size_t k = sizeof(std::vector<tt__IrCutFilterAutoAdjustment *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IrCutFilterAutoAdjustment *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IrCutFilterAutoAdjustment *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IrCutFilterAutoAdjustment *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, std::vector<enum tt__WhiteBalanceMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const std::vector<enum tt__WhiteBalanceMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__WhiteBalanceMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__WhiteBalanceMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WhiteBalanceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__WhiteBalanceMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, std::vector<enum tt__WhiteBalanceMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WhiteBalanceMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__WhiteBalanceMode n;
		soap_default_tt__WhiteBalanceMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__WhiteBalanceMode(soap, tag, NULL, "tt:WhiteBalanceMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WhiteBalanceMode(soap, tag, &n, "tt:WhiteBalanceMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__WhiteBalanceMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__WhiteBalanceMode> *p;
	size_t k = sizeof(std::vector<enum tt__WhiteBalanceMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__WhiteBalanceMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__WhiteBalanceMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__WhiteBalanceMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, std::vector<enum tt__ExposurePriority> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const std::vector<enum tt__ExposurePriority> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ExposurePriority> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ExposurePriority> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposurePriority(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ExposurePriority> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, std::vector<enum tt__ExposurePriority> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposurePriority(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ExposurePriority n;
		soap_default_tt__ExposurePriority(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposurePriority(soap, tag, &n, "tt:ExposurePriority"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ExposurePriority>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposurePriority(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ExposurePriority> *p;
	size_t k = sizeof(std::vector<enum tt__ExposurePriority> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ExposurePriority> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ExposurePriority> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ExposurePriority>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposureMode(struct soap *soap, std::vector<enum tt__ExposureMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const std::vector<enum tt__ExposureMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ExposureMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ExposureMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposureMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ExposureMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, std::vector<enum tt__ExposureMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposureMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ExposureMode n;
		soap_default_tt__ExposureMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, sizeof(enum tt__ExposureMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ExposureMode(soap, tag, NULL, "tt:ExposureMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposureMode(soap, tag, &n, "tt:ExposureMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ExposureMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposureMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ExposureMode> *p;
	size_t k = sizeof(std::vector<enum tt__ExposureMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ExposureMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ExposureMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ExposureMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, std::vector<enum tt__AutoFocusMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const std::vector<enum tt__AutoFocusMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__AutoFocusMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__AutoFocusMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AutoFocusMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__AutoFocusMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, std::vector<enum tt__AutoFocusMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AutoFocusMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__AutoFocusMode n;
		soap_default_tt__AutoFocusMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AutoFocusMode(soap, tag, NULL, "tt:AutoFocusMode"))
				break;
		}
		else
		{	if (!soap_in_tt__AutoFocusMode(soap, tag, &n, "tt:AutoFocusMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__AutoFocusMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__AutoFocusMode> *p;
	size_t k = sizeof(std::vector<enum tt__AutoFocusMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__AutoFocusMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__AutoFocusMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__AutoFocusMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, std::vector<enum tt__WideDynamicMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const std::vector<enum tt__WideDynamicMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__WideDynamicMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__WideDynamicMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WideDynamicMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__WideDynamicMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, std::vector<enum tt__WideDynamicMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WideDynamicMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__WideDynamicMode n;
		soap_default_tt__WideDynamicMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__WideDynamicMode(soap, tag, NULL, "tt:WideDynamicMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WideDynamicMode(soap, tag, &n, "tt:WideDynamicMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__WideDynamicMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__WideDynamicMode> *p;
	size_t k = sizeof(std::vector<enum tt__WideDynamicMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__WideDynamicMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__WideDynamicMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__WideDynamicMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, std::vector<enum tt__IrCutFilterMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const std::vector<enum tt__IrCutFilterMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__IrCutFilterMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__IrCutFilterMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IrCutFilterMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__IrCutFilterMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, std::vector<enum tt__IrCutFilterMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IrCutFilterMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__IrCutFilterMode n;
		soap_default_tt__IrCutFilterMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode"))
				break;
		}
		else
		{	if (!soap_in_tt__IrCutFilterMode(soap, tag, &n, "tt:IrCutFilterMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__IrCutFilterMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__IrCutFilterMode> *p;
	size_t k = sizeof(std::vector<enum tt__IrCutFilterMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__IrCutFilterMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__IrCutFilterMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__IrCutFilterMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, std::vector<enum tt__PTZPresetTourDirection> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const std::vector<enum tt__PTZPresetTourDirection> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, const std::vector<enum tt__PTZPresetTourDirection> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__PTZPresetTourDirection> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__PTZPresetTourDirection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__PTZPresetTourDirection> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const char *tag, std::vector<enum tt__PTZPresetTourDirection> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__PTZPresetTourDirection(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__PTZPresetTourDirection n;
		soap_default_tt__PTZPresetTourDirection(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPresetTourDirection, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__PTZPresetTourDirection(soap, tag, NULL, "tt:PTZPresetTourDirection"))
				break;
		}
		else
		{	if (!soap_in_tt__PTZPresetTourDirection(soap, tag, &n, "tt:PTZPresetTourDirection"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__PTZPresetTourDirection>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__PTZPresetTourDirection> *p;
	size_t k = sizeof(std::vector<enum tt__PTZPresetTourDirection> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__PTZPresetTourDirection> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__PTZPresetTourDirection> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__PTZPresetTourDirection>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, std::vector<tt__PTZPresetTourSpot *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const std::vector<tt__PTZPresetTourSpot *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZPresetTourSpot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZPresetTourSpot(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPresetTourSpot *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPresetTourSpot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZPresetTourSpot(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPresetTourSpot *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, std::vector<tt__PTZPresetTourSpot *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZPresetTourSpot *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZPresetTourSpot(soap, tag, NULL, "tt:PTZPresetTourSpot"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZPresetTourSpot(soap, tag, &n, "tt:PTZPresetTourSpot"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPresetTourSpot *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPresetTourSpot *> *p;
	size_t k = sizeof(std::vector<tt__PTZPresetTourSpot *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPresetTourSpot *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPresetTourSpot *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPresetTourSpot *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, std::vector<tt__Space1DDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const std::vector<tt__Space1DDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Space1DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space1DDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space1DDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Space1DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space1DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space1DDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, std::vector<tt__Space1DDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space1DDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Space1DDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, sizeof(tt__Space1DDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Space1DDescription(soap, tag, &n, "tt:Space1DDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space1DDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Space1DDescription *> *p;
	size_t k = sizeof(std::vector<tt__Space1DDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Space1DDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Space1DDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Space1DDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, std::vector<tt__Space2DDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const std::vector<tt__Space2DDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Space2DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space2DDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space2DDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Space2DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space2DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space2DDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, std::vector<tt__Space2DDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space2DDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Space2DDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, sizeof(tt__Space2DDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Space2DDescription(soap, tag, &n, "tt:Space2DDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space2DDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Space2DDescription *> *p;
	size_t k = sizeof(std::vector<tt__Space2DDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Space2DDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Space2DDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Space2DDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReverseMode(struct soap *soap, std::vector<enum tt__ReverseMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const std::vector<enum tt__ReverseMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ReverseMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ReverseMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReverseMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ReverseMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const char *tag, std::vector<enum tt__ReverseMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReverseMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ReverseMode n;
		soap_default_tt__ReverseMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_std__vectorTemplateOftt__ReverseMode, sizeof(enum tt__ReverseMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReverseMode(soap, tag, NULL, "tt:ReverseMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ReverseMode(soap, tag, &n, "tt:ReverseMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ReverseMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReverseMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReverseMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ReverseMode> *p;
	size_t k = sizeof(std::vector<enum tt__ReverseMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReverseMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ReverseMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ReverseMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ReverseMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__EFlipMode(struct soap *soap, std::vector<enum tt__EFlipMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const std::vector<enum tt__EFlipMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__EFlipMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__EFlipMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__EFlipMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__EFlipMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const char *tag, std::vector<enum tt__EFlipMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__EFlipMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__EFlipMode n;
		soap_default_tt__EFlipMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_std__vectorTemplateOftt__EFlipMode, sizeof(enum tt__EFlipMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__EFlipMode(soap, tag, NULL, "tt:EFlipMode"))
				break;
		}
		else
		{	if (!soap_in_tt__EFlipMode(soap, tag, &n, "tt:EFlipMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__EFlipMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__EFlipMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__EFlipMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__EFlipMode> *p;
	size_t k = sizeof(std::vector<enum tt__EFlipMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__EFlipMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__EFlipMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__EFlipMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__EFlipMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, std::vector<enum tt__PTZPresetTourOperation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const std::vector<enum tt__PTZPresetTourOperation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, const std::vector<enum tt__PTZPresetTourOperation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__PTZPresetTourOperation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__PTZPresetTourOperation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__PTZPresetTourOperation> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const char *tag, std::vector<enum tt__PTZPresetTourOperation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__PTZPresetTourOperation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__PTZPresetTourOperation n;
		soap_default_tt__PTZPresetTourOperation(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPresetTourOperation, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__PTZPresetTourOperation(soap, tag, NULL, "tt:PTZPresetTourOperation"))
				break;
		}
		else
		{	if (!soap_in_tt__PTZPresetTourOperation(soap, tag, &n, "tt:PTZPresetTourOperation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__PTZPresetTourOperation>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__PTZPresetTourOperation> *p;
	size_t k = sizeof(std::vector<enum tt__PTZPresetTourOperation> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__PTZPresetTourOperation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__PTZPresetTourOperation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__PTZPresetTourOperation>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, std::vector<tt__SystemLogUri *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const std::vector<tt__SystemLogUri *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__SystemLogUri(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, const std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__SystemLogUri(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SystemLogUri *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__SystemLogUri(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__SystemLogUri *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, sizeof(tt__SystemLogUri), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__SystemLogUri(soap, tag, NULL, "tt:SystemLogUri"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__SystemLogUri(soap, tag, &n, "tt:SystemLogUri"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SystemLogUri *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SystemLogUri *> *p;
	size_t k = sizeof(std::vector<tt__SystemLogUri *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SystemLogUri *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SystemLogUri *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SystemLogUri *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, std::vector<tt__OnvifVersion *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const std::vector<tt__OnvifVersion *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OnvifVersion(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, const std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OnvifVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OnvifVersion *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OnvifVersion(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__OnvifVersion *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, sizeof(tt__OnvifVersion), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__OnvifVersion(soap, tag, &n, "tt:OnvifVersion"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OnvifVersion *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OnvifVersion *> *p;
	size_t k = sizeof(std::vector<tt__OnvifVersion *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OnvifVersion *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OnvifVersion *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OnvifVersion *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__AuxiliaryData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AuxiliaryData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__AuxiliaryData(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData"))
				break;
		}
		else
		{	if (!soap_in_tt__AuxiliaryData(soap, tag, &n, "tt:AuxiliaryData"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, std::vector<enum tt__Dot11Cipher> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const std::vector<enum tt__Dot11Cipher> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, int id, const std::vector<enum tt__Dot11Cipher> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__Dot11Cipher> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11Cipher(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__Dot11Cipher> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, std::vector<enum tt__Dot11Cipher> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11Cipher(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__Dot11Cipher n;
		soap_default_tt__Dot11Cipher(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11Cipher(soap, tag, NULL, "tt:Dot11Cipher"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11Cipher(soap, tag, &n, "tt:Dot11Cipher"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__Dot11Cipher>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__Dot11Cipher> *p;
	size_t k = sizeof(std::vector<enum tt__Dot11Cipher> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__Dot11Cipher> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__Dot11Cipher> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__Dot11Cipher>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, std::vector<enum tt__Dot11AuthAndMangementSuite> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const std::vector<enum tt__Dot11AuthAndMangementSuite> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const std::vector<enum tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__Dot11AuthAndMangementSuite> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__Dot11AuthAndMangementSuite> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, std::vector<enum tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__Dot11AuthAndMangementSuite n;
		soap_default_tt__Dot11AuthAndMangementSuite(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, NULL, "tt:Dot11AuthAndMangementSuite"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, &n, "tt:Dot11AuthAndMangementSuite"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__Dot11AuthAndMangementSuite>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__Dot11AuthAndMangementSuite> *p;
	size_t k = sizeof(std::vector<enum tt__Dot11AuthAndMangementSuite> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__Dot11AuthAndMangementSuite> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__Dot11AuthAndMangementSuite> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__Dot11AuthAndMangementSuite>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, std::vector<tt__NetworkZeroConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const std::vector<tt__NetworkZeroConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkZeroConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkZeroConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, NULL, "tt:NetworkZeroConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, &n, "tt:NetworkZeroConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkZeroConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkZeroConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__NetworkZeroConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkZeroConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkZeroConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkZeroConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, std::vector<tt__PrefixedIPv6Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const std::vector<tt__PrefixedIPv6Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv6Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PrefixedIPv6Address *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, &n, "tt:PrefixedIPv6Address"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv6Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv6Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv6Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv6Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv6Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv6Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, std::vector<tt__PrefixedIPv4Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const std::vector<tt__PrefixedIPv4Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv4Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PrefixedIPv4Address *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, &n, "tt:PrefixedIPv4Address"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv4Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv4Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv4Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv4Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv4Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv4Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, std::vector<tt__Dot11Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const std::vector<tt__Dot11Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11Configuration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot11Configuration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, sizeof(tt__Dot11Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11Configuration(soap, tag, NULL, "tt:Dot11Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11Configuration(soap, tag, &n, "tt:Dot11Configuration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot11Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, std::vector<tt__Dot3Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const std::vector<tt__Dot3Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot3Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot3Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot3Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot3Configuration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot3Configuration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, sizeof(tt__Dot3Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot3Configuration(soap, tag, NULL, "tt:Dot3Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot3Configuration(soap, tag, &n, "tt:Dot3Configuration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot3Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot3Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot3Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot3Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot3Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot3Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, std::vector<tt__AudioEncoderConfigurationOption *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const std::vector<tt__AudioEncoderConfigurationOption *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioEncoderConfigurationOption(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioEncoderConfigurationOption *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioEncoderConfigurationOption *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, std::vector<tt__AudioEncoderConfigurationOption *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__AudioEncoderConfigurationOption *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, NULL, "tt:AudioEncoderConfigurationOption"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, &n, "tt:AudioEncoderConfigurationOption"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfigurationOption *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioEncoderConfigurationOption *> *p;
	size_t k = sizeof(std::vector<tt__AudioEncoderConfigurationOption *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioEncoderConfigurationOption *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioEncoderConfigurationOption *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioEncoderConfigurationOption *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, std::vector<tt__VideoResolution2 *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, const std::vector<tt__VideoResolution2 *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoResolution2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoResolution2(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoResolution2 *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoResolution2 *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoResolution2(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoResolution2 *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, const char *tag, std::vector<tt__VideoResolution2 *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoResolution2(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoResolution2 *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoResolution2, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution2, sizeof(tt__VideoResolution2), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoResolution2(soap, tag, NULL, "tt:VideoResolution2"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoResolution2(soap, tag, &n, "tt:VideoResolution2"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoResolution2 *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoResolution2 *> *p;
	size_t k = sizeof(std::vector<tt__VideoResolution2 *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoResolution2 *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoResolution2 *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoResolution2 *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__H264Profile(struct soap *soap, std::vector<enum tt__H264Profile> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__H264Profile(struct soap *soap, const std::vector<enum tt__H264Profile> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, int id, const std::vector<enum tt__H264Profile> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__H264Profile> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__H264Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__H264Profile> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, std::vector<enum tt__H264Profile> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__H264Profile(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__H264Profile n;
		soap_default_tt__H264Profile(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__H264Profile, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, sizeof(enum tt__H264Profile), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__H264Profile(soap, tag, NULL, "tt:H264Profile"))
				break;
		}
		else
		{	if (!soap_in_tt__H264Profile(soap, tag, &n, "tt:H264Profile"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__H264Profile>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__H264Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__H264Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__H264Profile> *p;
	size_t k = sizeof(std::vector<enum tt__H264Profile> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__H264Profile> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__H264Profile> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__H264Profile>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, std::vector<enum tt__Mpeg4Profile> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const std::vector<enum tt__Mpeg4Profile> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const std::vector<enum tt__Mpeg4Profile> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__Mpeg4Profile> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Mpeg4Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__Mpeg4Profile> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, std::vector<enum tt__Mpeg4Profile> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Mpeg4Profile(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__Mpeg4Profile n;
		soap_default_tt__Mpeg4Profile(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile"))
				break;
		}
		else
		{	if (!soap_in_tt__Mpeg4Profile(soap, tag, &n, "tt:Mpeg4Profile"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__Mpeg4Profile>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__Mpeg4Profile> *p;
	size_t k = sizeof(std::vector<enum tt__Mpeg4Profile> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__Mpeg4Profile> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__Mpeg4Profile> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__Mpeg4Profile>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, std::vector<tt__VideoResolution *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const std::vector<tt__VideoResolution *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoResolution(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoResolution *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoResolution(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoResolution *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, std::vector<tt__VideoResolution *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoResolution(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoResolution *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, sizeof(tt__VideoResolution), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoResolution(soap, tag, NULL, "tt:VideoResolution"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoResolution(soap, tag, &n, "tt:VideoResolution"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoResolution *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoResolution *> *p;
	size_t k = sizeof(std::vector<tt__VideoResolution *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoResolution *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoResolution *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoResolution *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__RotateMode(struct soap *soap, std::vector<enum tt__RotateMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__RotateMode(struct soap *soap, const std::vector<enum tt__RotateMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__RotateMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__RotateMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__RotateMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__RotateMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__RotateMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__RotateMode(struct soap *soap, const char *tag, std::vector<enum tt__RotateMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__RotateMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__RotateMode n;
		soap_default_tt__RotateMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RotateMode, SOAP_TYPE_std__vectorTemplateOftt__RotateMode, sizeof(enum tt__RotateMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__RotateMode(soap, tag, NULL, "tt:RotateMode"))
				break;
		}
		else
		{	if (!soap_in_tt__RotateMode(soap, tag, &n, "tt:RotateMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__RotateMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__RotateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__RotateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__RotateMode> *p;
	size_t k = sizeof(std::vector<enum tt__RotateMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__RotateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__RotateMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__RotateMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__RotateMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, std::vector<enum tt__SceneOrientationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const std::vector<enum tt__SceneOrientationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__SceneOrientationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__SceneOrientationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__SceneOrientationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__SceneOrientationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const char *tag, std::vector<enum tt__SceneOrientationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__SceneOrientationMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__SceneOrientationMode n;
		soap_default_tt__SceneOrientationMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode, sizeof(enum tt__SceneOrientationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__SceneOrientationMode(soap, tag, NULL, "tt:SceneOrientationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__SceneOrientationMode(soap, tag, &n, "tt:SceneOrientationMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__SceneOrientationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__SceneOrientationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__SceneOrientationMode> *p;
	size_t k = sizeof(std::vector<enum tt__SceneOrientationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__SceneOrientationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__SceneOrientationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__SceneOrientationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, std::vector<tt__LensProjection *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const std::vector<tt__LensProjection *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensProjection(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, int id, const std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensProjection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensProjection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensProjection(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__LensProjection *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__LensProjection, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, sizeof(tt__LensProjection), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LensProjection(soap, tag, NULL, "tt:LensProjection"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensProjection(soap, tag, &n, "tt:LensProjection"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensProjection *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensProjection *> *p;
	size_t k = sizeof(std::vector<tt__LensProjection *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensProjection *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensProjection *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensProjection *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, std::vector<tt__LensDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const std::vector<tt__LensDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__LensDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__LensDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, sizeof(tt__LensDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LensDescription(soap, tag, NULL, "tt:LensDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensDescription(soap, tag, &n, "tt:LensDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensDescription *> *p;
	size_t k = sizeof(std::vector<tt__LensDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffloat(struct soap *soap, std::vector<float> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffloat(struct soap *soap, const std::vector<float> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffloat(struct soap *soap, const char *tag, int id, const std::vector<float> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<float> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_float(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<float> * SOAP_FMAC4 soap_in_std__vectorTemplateOffloat(struct soap *soap, const char *tag, std::vector<float> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOffloat(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		float n;
		soap_default_float(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_float, SOAP_TYPE_std__vectorTemplateOffloat, sizeof(float), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_float(soap, tag, NULL, "xsd:float"))
				break;
		}
		else
		{	if (!soap_in_float(soap, tag, &n, "xsd:float"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<float>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOffloat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffloat(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<float> *p;
	size_t k = sizeof(std::vector<float> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOffloat, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<float> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<float> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<float>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<int> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int> * SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfint(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		int n;
		soap_default_int(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{	if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<int> *p;
	size_t k = sizeof(std::vector<int> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<int> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<int> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<int>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(struct soap *soap, std::vector<_tt__ColorDescriptor_ColorCluster> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(struct soap *soap, const std::vector<_tt__ColorDescriptor_ColorCluster> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ColorDescriptor_ColorCluster> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, const std::vector<_tt__ColorDescriptor_ColorCluster> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ColorDescriptor_ColorCluster> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ColorDescriptor_ColorCluster> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, std::vector<_tt__ColorDescriptor_ColorCluster> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		_tt__ColorDescriptor_ColorCluster n;
		n.soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE__tt__ColorDescriptor_ColorCluster, SOAP_TYPE_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster, sizeof(_tt__ColorDescriptor_ColorCluster), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, &n, ""))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ColorDescriptor_ColorCluster));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(_tt__ColorDescriptor_ColorCluster));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(_tt__ColorDescriptor_ColorCluster));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ColorDescriptor_ColorCluster>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ColorDescriptor_ColorCluster> *p;
	size_t k = sizeof(std::vector<_tt__ColorDescriptor_ColorCluster> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ColorDescriptor_ColorCluster> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ColorDescriptor_ColorCluster> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ColorDescriptor_ColorCluster>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, std::vector<tt__Vector *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const std::vector<tt__Vector *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Vector(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, int id, const std::vector<tt__Vector *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Vector(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Vector *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, std::vector<tt__Vector *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Vector(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Vector *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Vector, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, sizeof(tt__Vector), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Vector(soap, tag, NULL, "tt:Vector"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Vector(soap, tag, &n, "tt:Vector"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Vector *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Vector *> *p;
	size_t k = sizeof(std::vector<tt__Vector *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Vector *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Vector *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Vector *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(struct soap *soap, std::vector<tt__GetRecordingJobsResponseItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(struct soap *soap, const std::vector<tt__GetRecordingJobsResponseItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__GetRecordingJobsResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__GetRecordingJobsResponseItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, const std::vector<tt__GetRecordingJobsResponseItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__GetRecordingJobsResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__GetRecordingJobsResponseItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__GetRecordingJobsResponseItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, std::vector<tt__GetRecordingJobsResponseItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__GetRecordingJobsResponseItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__GetRecordingJobsResponseItem, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem, sizeof(tt__GetRecordingJobsResponseItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__GetRecordingJobsResponseItem(soap, tag, NULL, "tt:GetRecordingJobsResponseItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__GetRecordingJobsResponseItem(soap, tag, &n, "tt:GetRecordingJobsResponseItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__GetRecordingJobsResponseItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__GetRecordingJobsResponseItem *> *p;
	size_t k = sizeof(std::vector<tt__GetRecordingJobsResponseItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetRecordingJobsResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__GetRecordingJobsResponseItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__GetRecordingJobsResponseItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__GetRecordingJobsResponseItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(struct soap *soap, std::vector<tt__GetRecordingsResponseItem *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(struct soap *soap, const std::vector<tt__GetRecordingsResponseItem *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__GetRecordingsResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__GetRecordingsResponseItem(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, const std::vector<tt__GetRecordingsResponseItem *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__GetRecordingsResponseItem *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__GetRecordingsResponseItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__GetRecordingsResponseItem *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(struct soap *soap, const char *tag, std::vector<tt__GetRecordingsResponseItem *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__GetRecordingsResponseItem *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__GetRecordingsResponseItem, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem, sizeof(tt__GetRecordingsResponseItem), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__GetRecordingsResponseItem(soap, tag, NULL, "tt:GetRecordingsResponseItem"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__GetRecordingsResponseItem(soap, tag, &n, "tt:GetRecordingsResponseItem"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__GetRecordingsResponseItem *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__GetRecordingsResponseItem *> *p;
	size_t k = sizeof(std::vector<tt__GetRecordingsResponseItem *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__GetRecordingsResponseItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__GetRecordingsResponseItem *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__GetRecordingsResponseItem *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__GetRecordingsResponseItem *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Receiver(struct soap *soap, std::vector<tt__Receiver *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Receiver(struct soap *soap, const std::vector<tt__Receiver *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Receiver *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Receiver(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Receiver(struct soap *soap, const char *tag, int id, const std::vector<tt__Receiver *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Receiver *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Receiver(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Receiver *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Receiver(struct soap *soap, const char *tag, std::vector<tt__Receiver *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Receiver(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Receiver *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Receiver, SOAP_TYPE_std__vectorTemplateOfPointerTott__Receiver, sizeof(tt__Receiver), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Receiver(soap, tag, NULL, "tt:Receiver"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Receiver(soap, tag, &n, "tt:Receiver"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Receiver *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Receiver(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Receiver(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Receiver *> *p;
	size_t k = sizeof(std::vector<tt__Receiver *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Receiver, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Receiver *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Receiver *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Receiver *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotmd__SerialPort(struct soap *soap, std::vector<tmd__SerialPort *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotmd__SerialPort(struct soap *soap, const std::vector<tmd__SerialPort *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tmd__SerialPort *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotmd__SerialPort(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotmd__SerialPort(struct soap *soap, const char *tag, int id, const std::vector<tmd__SerialPort *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tmd__SerialPort *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotmd__SerialPort(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tmd__SerialPort *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotmd__SerialPort(struct soap *soap, const char *tag, std::vector<tmd__SerialPort *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotmd__SerialPort(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tmd__SerialPort *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tmd__SerialPort, SOAP_TYPE_std__vectorTemplateOfPointerTotmd__SerialPort, sizeof(tmd__SerialPort), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotmd__SerialPort(soap, tag, NULL, "tmd:SerialPort"))
				break;
		}
		else
		{	if (!soap_in_PointerTotmd__SerialPort(soap, tag, &n, "tmd:SerialPort"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tmd__SerialPort *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotmd__SerialPort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotmd__SerialPort(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tmd__SerialPort *> *p;
	size_t k = sizeof(std::vector<tmd__SerialPort *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotmd__SerialPort, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tmd__SerialPort *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tmd__SerialPort *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tmd__SerialPort *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__DigitalInput(struct soap *soap, std::vector<tt__DigitalInput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__DigitalInput(struct soap *soap, const std::vector<tt__DigitalInput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__DigitalInput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__DigitalInput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__DigitalInput(struct soap *soap, const char *tag, int id, const std::vector<tt__DigitalInput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__DigitalInput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__DigitalInput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__DigitalInput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__DigitalInput(struct soap *soap, const char *tag, std::vector<tt__DigitalInput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__DigitalInput(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__DigitalInput *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__DigitalInput, SOAP_TYPE_std__vectorTemplateOfPointerTott__DigitalInput, sizeof(tt__DigitalInput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__DigitalInput(soap, tag, NULL, "tt:DigitalInput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__DigitalInput(soap, tag, &n, "tt:DigitalInput"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__DigitalInput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__DigitalInput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__DigitalInput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__DigitalInput *> *p;
	size_t k = sizeof(std::vector<tt__DigitalInput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__DigitalInput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__DigitalInput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__DigitalInput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__DigitalInput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoOutput(struct soap *soap, std::vector<tt__VideoOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoOutput(struct soap *soap, const std::vector<tt__VideoOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoOutput(struct soap *soap, const char *tag, std::vector<tt__VideoOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoOutput(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__VideoOutput *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__VideoOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoOutput, sizeof(tt__VideoOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoOutput(soap, tag, NULL, "tt:VideoOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoOutput(soap, tag, &n, "tt:VideoOutput"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoOutput *> *p;
	size_t k = sizeof(std::vector<tt__VideoOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(struct soap *soap, std::vector<tmd__RelayOutputOptions *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(struct soap *soap, const std::vector<tmd__RelayOutputOptions *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tmd__RelayOutputOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotmd__RelayOutputOptions(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(struct soap *soap, const char *tag, int id, const std::vector<tmd__RelayOutputOptions *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tmd__RelayOutputOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotmd__RelayOutputOptions(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tmd__RelayOutputOptions *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(struct soap *soap, const char *tag, std::vector<tmd__RelayOutputOptions *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tmd__RelayOutputOptions *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tmd__RelayOutputOptions, SOAP_TYPE_std__vectorTemplateOfPointerTotmd__RelayOutputOptions, sizeof(tmd__RelayOutputOptions), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotmd__RelayOutputOptions(soap, tag, NULL, "tmd:RelayOutputOptions"))
				break;
		}
		else
		{	if (!soap_in_PointerTotmd__RelayOutputOptions(soap, tag, &n, "tmd:RelayOutputOptions"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tmd__RelayOutputOptions *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotmd__RelayOutputOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tmd__RelayOutputOptions *> *p;
	size_t k = sizeof(std::vector<tmd__RelayOutputOptions *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotmd__RelayOutputOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tmd__RelayOutputOptions *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tmd__RelayOutputOptions *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tmd__RelayOutputOptions *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftmd__ParityBit(struct soap *soap, std::vector<enum tmd__ParityBit> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftmd__ParityBit(struct soap *soap, const std::vector<enum tmd__ParityBit> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftmd__ParityBit(struct soap *soap, const char *tag, int id, const std::vector<enum tmd__ParityBit> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tmd__ParityBit> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tmd__ParityBit(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tmd__ParityBit> * SOAP_FMAC4 soap_in_std__vectorTemplateOftmd__ParityBit(struct soap *soap, const char *tag, std::vector<enum tmd__ParityBit> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftmd__ParityBit(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tmd__ParityBit n;
		soap_default_tmd__ParityBit(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tmd__ParityBit, SOAP_TYPE_std__vectorTemplateOftmd__ParityBit, sizeof(enum tmd__ParityBit), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tmd__ParityBit(soap, tag, NULL, "tmd:ParityBit"))
				break;
		}
		else
		{	if (!soap_in_tmd__ParityBit(soap, tag, &n, "tmd:ParityBit"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tmd__ParityBit>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftmd__ParityBit(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftmd__ParityBit(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tmd__ParityBit> *p;
	size_t k = sizeof(std::vector<enum tmd__ParityBit> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftmd__ParityBit, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tmd__ParityBit> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tmd__ParityBit> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tmd__ParityBit>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__DigitalIdleState(struct soap *soap, std::vector<enum tt__DigitalIdleState> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__DigitalIdleState(struct soap *soap, const std::vector<enum tt__DigitalIdleState> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__DigitalIdleState(struct soap *soap, const char *tag, int id, const std::vector<enum tt__DigitalIdleState> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__DigitalIdleState> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__DigitalIdleState(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__DigitalIdleState> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__DigitalIdleState(struct soap *soap, const char *tag, std::vector<enum tt__DigitalIdleState> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__DigitalIdleState(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__DigitalIdleState n;
		soap_default_tt__DigitalIdleState(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__DigitalIdleState, SOAP_TYPE_std__vectorTemplateOftt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__DigitalIdleState(soap, tag, NULL, "tt:DigitalIdleState"))
				break;
		}
		else
		{	if (!soap_in_tt__DigitalIdleState(soap, tag, &n, "tt:DigitalIdleState"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__DigitalIdleState>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__DigitalIdleState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__DigitalIdleState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__DigitalIdleState> *p;
	size_t k = sizeof(std::vector<enum tt__DigitalIdleState> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__DigitalIdleState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__DigitalIdleState> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__DigitalIdleState> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__DigitalIdleState>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__RelayMode(struct soap *soap, std::vector<enum tt__RelayMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__RelayMode(struct soap *soap, const std::vector<enum tt__RelayMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__RelayMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__RelayMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__RelayMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__RelayMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__RelayMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__RelayMode(struct soap *soap, const char *tag, std::vector<enum tt__RelayMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__RelayMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__RelayMode n;
		soap_default_tt__RelayMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RelayMode, SOAP_TYPE_std__vectorTemplateOftt__RelayMode, sizeof(enum tt__RelayMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__RelayMode(soap, tag, NULL, "tt:RelayMode"))
				break;
		}
		else
		{	if (!soap_in_tt__RelayMode(soap, tag, &n, "tt:RelayMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__RelayMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__RelayMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__RelayMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__RelayMode> *p;
	size_t k = sizeof(std::vector<enum tt__RelayMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__RelayMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__RelayMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__RelayMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__RelayMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, std::vector<tt__LocationEntity *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const std::vector<tt__LocationEntity *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LocationEntity(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, int id, const std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LocationEntity(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LocationEntity *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LocationEntity(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__LocationEntity *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, sizeof(tt__LocationEntity), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LocationEntity(soap, tag, NULL, "tt:LocationEntity"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LocationEntity(soap, tag, &n, "tt:LocationEntity"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LocationEntity *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LocationEntity *> *p;
	size_t k = sizeof(std::vector<tt__LocationEntity *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LocationEntity *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LocationEntity *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LocationEntity *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, std::vector<tds__StorageConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const std::vector<tds__StorageConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__StorageConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__StorageConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__StorageConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tds__StorageConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, sizeof(tds__StorageConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, NULL, "tds:StorageConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, &n, "tds:StorageConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__StorageConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__StorageConfiguration *> *p;
	size_t k = sizeof(std::vector<tds__StorageConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__StorageConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__StorageConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__StorageConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, std::vector<tt__Dot11AvailableNetworks *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const std::vector<tt__Dot11AvailableNetworks *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11AvailableNetworks(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11AvailableNetworks *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot11AvailableNetworks *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, NULL, "tt:Dot11AvailableNetworks"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, &n, "tt:Dot11AvailableNetworks"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11AvailableNetworks *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11AvailableNetworks *> *p;
	size_t k = sizeof(std::vector<tt__Dot11AvailableNetworks *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11AvailableNetworks *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11AvailableNetworks *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11AvailableNetworks *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, std::vector<tt__RelayOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const std::vector<tt__RelayOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RelayOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RelayOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RelayOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RelayOutput(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__RelayOutput *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, sizeof(tt__RelayOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RelayOutput(soap, tag, NULL, "tt:RelayOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RelayOutput(soap, tag, &n, "tt:RelayOutput"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RelayOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RelayOutput *> *p;
	size_t k = sizeof(std::vector<tt__RelayOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RelayOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RelayOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RelayOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__ReferenceToken(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReferenceToken(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReferenceToken(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__ReferenceToken(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken"))
				break;
		}
		else
		{	if (!soap_in_tt__ReferenceToken(soap, tag, &n, "tt:ReferenceToken"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReferenceToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, std::vector<tt__Dot1XConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const std::vector<tt__Dot1XConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot1XConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot1XConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot1XConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Dot1XConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, NULL, "tt:Dot1XConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, &n, "tt:Dot1XConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot1XConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot1XConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__Dot1XConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot1XConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot1XConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot1XConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, std::vector<tt__CertificateWithPrivateKey *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const std::vector<tt__CertificateWithPrivateKey *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateWithPrivateKey(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateWithPrivateKey *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__CertificateWithPrivateKey *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, NULL, "tt:CertificateWithPrivateKey"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, &n, "tt:CertificateWithPrivateKey"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateWithPrivateKey *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateWithPrivateKey *> *p;
	size_t k = sizeof(std::vector<tt__CertificateWithPrivateKey *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateWithPrivateKey *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateWithPrivateKey *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateWithPrivateKey *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, std::vector<tt__CertificateStatus *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const std::vector<tt__CertificateStatus *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateStatus(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateStatus *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateStatus(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__CertificateStatus *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, sizeof(tt__CertificateStatus), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateStatus(soap, tag, NULL, "tt:CertificateStatus"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateStatus(soap, tag, &n, "tt:CertificateStatus"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateStatus *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateStatus *> *p;
	size_t k = sizeof(std::vector<tt__CertificateStatus *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateStatus *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateStatus *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateStatus *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, std::vector<tt__Certificate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const std::vector<tt__Certificate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Certificate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, int id, const std::vector<tt__Certificate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Certificate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Certificate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, std::vector<tt__Certificate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Certificate(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Certificate *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Certificate, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, sizeof(tt__Certificate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Certificate(soap, tag, NULL, "tt:Certificate"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Certificate(soap, tag, &n, "tt:Certificate"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Certificate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Certificate *> *p;
	size_t k = sizeof(std::vector<tt__Certificate *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Certificate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Certificate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Certificate *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv6Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv6Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__IPv6Address(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IPv6Address, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv6Address(soap, tag, &n, "tt:IPv6Address"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv4Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv4Address(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__IPv4Address(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IPv4Address, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv4Address(soap, tag, &n, "tt:IPv4Address"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, std::vector<tt__NetworkProtocol *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const std::vector<tt__NetworkProtocol *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkProtocol(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkProtocol(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkProtocol *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkProtocol(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkProtocol *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, sizeof(tt__NetworkProtocol), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkProtocol(soap, tag, NULL, "tt:NetworkProtocol"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkProtocol(soap, tag, &n, "tt:NetworkProtocol"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkProtocol *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkProtocol *> *p;
	size_t k = sizeof(std::vector<tt__NetworkProtocol *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkProtocol *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkProtocol *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkProtocol *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, std::vector<tt__NetworkInterface *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const std::vector<tt__NetworkInterface *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkInterface(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkInterface(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkInterface *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkInterface(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkInterface *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, sizeof(tt__NetworkInterface), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkInterface(soap, tag, NULL, "tt:NetworkInterface"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkInterface(soap, tag, &n, "tt:NetworkInterface"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkInterface *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkInterface *> *p;
	size_t k = sizeof(std::vector<tt__NetworkInterface *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkInterface *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkInterface *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkInterface *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, std::vector<tt__IPAddress *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const std::vector<tt__IPAddress *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IPAddress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, int id, const std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IPAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IPAddress *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IPAddress(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__IPAddress *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__IPAddress, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, sizeof(tt__IPAddress), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IPAddress(soap, tag, &n, "tt:IPAddress"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IPAddress *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IPAddress *> *p;
	size_t k = sizeof(std::vector<tt__IPAddress *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IPAddress *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IPAddress *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IPAddress *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__token(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__token(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__token(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__token(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__token(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__token(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__token, SOAP_TYPE_std__vectorTemplateOfxsd__token, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__token(soap, tag, NULL, "xsd:token"))
				break;
		}
		else
		{	if (!soap_in_xsd__token(soap, tag, &n, "xsd:token"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__token(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__token, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, std::vector<enum tt__CapabilityCategory> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const std::vector<enum tt__CapabilityCategory> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, int id, const std::vector<enum tt__CapabilityCategory> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__CapabilityCategory> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__CapabilityCategory(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__CapabilityCategory> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, std::vector<enum tt__CapabilityCategory> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__CapabilityCategory(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__CapabilityCategory n;
		soap_default_tt__CapabilityCategory(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory"))
				break;
		}
		else
		{	if (!soap_in_tt__CapabilityCategory(soap, tag, &n, "tt:CapabilityCategory"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__CapabilityCategory>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__CapabilityCategory> *p;
	size_t k = sizeof(std::vector<enum tt__CapabilityCategory> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__CapabilityCategory> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__CapabilityCategory> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__CapabilityCategory>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_std__string(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__User(struct soap *soap, std::vector<tt__User *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__User(struct soap *soap, const std::vector<tt__User *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__User(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, int id, const std::vector<tt__User *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__User(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__User *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, std::vector<tt__User *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__User(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__User *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__User, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, sizeof(tt__User), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__User(soap, tag, NULL, "tt:User"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__User(soap, tag, &n, "tt:User"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__User *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__User *> *p;
	size_t k = sizeof(std::vector<tt__User *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__User *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__User *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__User *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, std::vector<tt__NetworkHost *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const std::vector<tt__NetworkHost *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkHost(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkHost(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkHost *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkHost(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__NetworkHost *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, sizeof(tt__NetworkHost), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkHost(soap, tag, NULL, "tt:NetworkHost"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkHost(soap, tag, &n, "tt:NetworkHost"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkHost *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkHost *> *p;
	size_t k = sizeof(std::vector<tt__NetworkHost *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkHost *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkHost *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkHost *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, std::vector<tt__Scope *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const std::vector<tt__Scope *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Scope(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, int id, const std::vector<tt__Scope *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Scope(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Scope *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, std::vector<tt__Scope *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Scope(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Scope *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Scope, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, sizeof(tt__Scope), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Scope(soap, tag, NULL, "tt:Scope"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Scope(soap, tag, &n, "tt:Scope"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Scope *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Scope *> *p;
	size_t k = sizeof(std::vector<tt__Scope *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Scope *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Scope *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Scope *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, std::vector<tt__BackupFile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const std::vector<tt__BackupFile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__BackupFile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, int id, const std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__BackupFile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__BackupFile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__BackupFile(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__BackupFile *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__BackupFile, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, sizeof(tt__BackupFile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__BackupFile(soap, tag, NULL, "tt:BackupFile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__BackupFile(soap, tag, &n, "tt:BackupFile"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__BackupFile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__BackupFile *> *p;
	size_t k = sizeof(std::vector<tt__BackupFile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__BackupFile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__BackupFile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__BackupFile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, std::vector<tds__Service *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const std::vector<tds__Service *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__Service(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, int id, const std::vector<tds__Service *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__Service(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__Service *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, std::vector<tds__Service *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__Service(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tds__Service *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tds__Service, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, sizeof(tds__Service), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__Service(soap, tag, NULL, "tds:Service"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__Service(soap, tag, &n, "tds:Service"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__Service *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__Service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__Service *> *p;
	size_t k = sizeof(std::vector<tds__Service *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__Service *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__Service *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__Service *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, std::vector<tt__PresetTour *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, const std::vector<tt__PresetTour *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PresetTour *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PresetTour(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, const char *tag, int id, const std::vector<tt__PresetTour *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PresetTour *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PresetTour(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PresetTour *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, const char *tag, std::vector<tt__PresetTour *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PresetTour(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PresetTour *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PresetTour, SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour, sizeof(tt__PresetTour), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PresetTour(soap, tag, NULL, "tt:PresetTour"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PresetTour(soap, tag, &n, "tt:PresetTour"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PresetTour *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PresetTour *> *p;
	size_t k = sizeof(std::vector<tt__PresetTour *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PresetTour *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PresetTour *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PresetTour *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, std::vector<tt__PTZPreset *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, const std::vector<tt__PTZPreset *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZPreset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPreset *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZPreset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, const char *tag, std::vector<tt__PTZPreset *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZPreset(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZPreset *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset, sizeof(tt__PTZPreset), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZPreset(soap, tag, NULL, "tt:PTZPreset"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZPreset(soap, tag, &n, "tt:PTZPreset"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPreset *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPreset *> *p;
	size_t k = sizeof(std::vector<tt__PTZPreset *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPreset *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPreset *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPreset *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, std::vector<tt__PTZConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, const std::vector<tt__PTZConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, const char *tag, std::vector<tt__PTZConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration, sizeof(tt__PTZConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZConfiguration(soap, tag, NULL, "tt:PTZConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZConfiguration(soap, tag, &n, "tt:PTZConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__PTZConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, std::vector<tt__PTZNode *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, const std::vector<tt__PTZNode *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZNode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZNode(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZNode *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZNode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZNode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZNode *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, const char *tag, std::vector<tt__PTZNode *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZNode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZNode *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZNode, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode, sizeof(tt__PTZNode), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZNode(soap, tag, NULL, "tt:PTZNode"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZNode(soap, tag, &n, "tt:PTZNode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZNode *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZNode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZNode *> *p;
	size_t k = sizeof(std::vector<tt__PTZNode *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZNode *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZNode *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZNode *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PaneConfiguration(struct soap *soap, std::vector<tt__PaneConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PaneConfiguration(struct soap *soap, const std::vector<tt__PaneConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PaneConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PaneConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PaneConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__PaneConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PaneConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PaneConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PaneConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PaneConfiguration(struct soap *soap, const char *tag, std::vector<tt__PaneConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PaneConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PaneConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PaneConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneConfiguration, sizeof(tt__PaneConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PaneConfiguration(soap, tag, NULL, "tt:PaneConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PaneConfiguration(soap, tag, &n, "tt:PaneConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PaneConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PaneConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PaneConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PaneConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__PaneConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PaneConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PaneConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PaneConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, std::vector<wsnt__NotificationMessageHolderType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const std::vector<wsnt__NotificationMessageHolderType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsnt__NotificationMessageHolderType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, &n, "wsnt:NotificationMessageHolderType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__NotificationMessageHolderType *> *p;
	size_t k = sizeof(std::vector<wsnt__NotificationMessageHolderType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__NotificationMessageHolderType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__NotificationMessageHolderType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__NotificationMessageHolderType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_xsd__anyURI(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, &n, "xsd:anyURI"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, std::vector<wsnt__TopicExpressionType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const std::vector<wsnt__TopicExpressionType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__TopicExpressionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		wsnt__TopicExpressionType *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, &n, "wsnt:TopicExpressionType"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__TopicExpressionType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__TopicExpressionType *> *p;
	size_t k = sizeof(std::vector<wsnt__TopicExpressionType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__TopicExpressionType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__TopicExpressionType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__TopicExpressionType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyType(struct soap *soap, std::vector<struct soap_dom_element> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyType(struct soap *soap, const std::vector<struct soap_dom_element> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<struct soap_dom_element> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, int id, const std::vector<struct soap_dom_element> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<struct soap_dom_element> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<struct soap_dom_element> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyType(struct soap *soap, const char *tag, std::vector<struct soap_dom_element> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyType(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		struct soap_dom_element n;
		soap_default_xsd__anyType(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_xsd__anyType, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, sizeof(struct soap_dom_element), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyType(soap, tag, &n, "xsd:anyType"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(struct soap_dom_element));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(struct soap_dom_element));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(struct soap_dom_element));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<struct soap_dom_element>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<struct soap_dom_element> *p;
	size_t k = sizeof(std::vector<struct soap_dom_element> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<struct soap_dom_element> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<struct soap_dom_element> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<struct soap_dom_element>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
